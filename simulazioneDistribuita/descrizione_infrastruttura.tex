
\section{Descrizione dell'infrastruttura}
L'architettura alla base delle comunicazioni tra i vari nodi della libreria è di natura \textbf{master/slave}.
Più specificatamente, le simulazioni da eseguire sono sottomesse da parte di un \textbf{client} che si connette ad un \textbf{master server} disponibile pubblicamente in rete, da cui vengono provengono anche i risultati delle simulazioni. 
All'interno della rete locale al master sono quindi presenti gli \textbf{slave server} che rappresentano le unità di elaborazione delle simulazioni. Questi server non sono disponibili pubblicamente in rete e interagiscono con il master per poter ricevere nuove simulazioni da eseguire e per poter restituire i risultati di tali simulazioni.

\subsection{Client}
La logica di funzionamento di un \textbf{client} è contenuta interamente nella classe \texttt{clientSimulationEnvironment}, le cui istanze devono essere incluse in tutte le classi di avvio di un client.
Nella definizione della classe di avvio di un client server è necessario includere l'istanziazione di un oggetto della classe \texttt{ModelDefinition}, rappresentante il modello della simulazione che verrà sottomesso per essere elaborato, e parametri relativi alla simulazione quali il numero delle repliche e la deadline [?].

Alla sua creazione, l'istanza di \texttt{clientSimulationEnvironment} cercherà di contattare tramite la rete un master server utilizzando i parametri definiti all'avvio, quali porta, indirizzo IP e tipo di comunicazione basata su TCP. 
Durante questa fase vengono trasmessi al master server i byte contenuti nel file compilato .class relativo alla classe che implementa \texttt{ModelDefinition}, istanziata all'avvio del client.
Il caricamento di queste informazioni nel master server risulta fondamentale per poter gestire correttamente i dati e i parametri relativi alla simulazione che sono trasmessi dal client successivamente alla prima fase.

L'invio di questi dati coincide con la sottomissione effettiva della simulazione al master server. 
Tutte le comunicazioni successive a questa fase riguardano la ricezione dei risultati da parte del master server e la chiusura della comunicazione sia lato client che lato master server.

\subsection{Master server}

Sottosezione del master

\subsection{Slave server}
La classe alla base del funzionamento di uno \textbf{slave server} è \texttt{DiscoverableBasicSimulationServer}, estensione della classe \texttt{BasicSimulationServer}.
La classe \texttt{BasicSimulationServer} è stata rivista per poter implementare il nuovo protocollo di comunicazione con i master server ma la logica è rimasta la medesima:
le istanze di tale classe sono infatti forniti di due istanze di \texttt{ExecutorService} basati su \texttt{CachedThreadPool} per poter gestire, rispettivamente, le connessioni in ingresso da parte di master server
e per gestire in maniera efficiente i task di simulazione sottomessi sfruttando le capacità di \textbf{multithreading} dello slave server.
Nella corrente implementazione di \texttt{BasicSimulationServer} è inoltre presente la gestione della comunicazione con i master server per poter ricevere da questi e caricare in memoria i byte dei file .class associati
alle simulazioni da eseguire e, successivamente, anche i parametri e i dati di tali simulazioni, oltre che per poter inviare ai master server i risultati delle simulazioni richieste una volta che la loro esecuzione è terminata.
Tra le funzionalità presenti nella classe si annoverano anche la possibilità di chiudere la connessione con i master server che lo richiedono, nel caso ideale dopo aver ricevuto i risultati delle simulazioni sottomesse,
e di rispondere ai messaggi di ping che i master server potrebbero inviare in caso sia stato rilevato un timeout. 

Il comportamento aggiuntivo introdotto tramite la classe \texttt{DiscoverableBasicSimulationServer} si focalizza sulla possibilità per uno slave server di essere individuato nella propria rete locale da tutti i master server
presenti all'interno della medesima rete. Ogni slave server riceve infatti periodicamente \textbf{messaggi di discovery} inviati in modalità broadcast dai master server presenti. Rispondendo a tali messaggi, il singolo slave server
permette di risultare visibile ai master server che, alla successiva interazione da parte di client, lo contatteranno per poter sottomettere nuove simulazioni.
Nell'attuale implementazione, gli slave server rispondono ad ogni messaggio di broadcast inviato dai master server presenti nella loro rete. Non conoscendo a priori lo stato del master server e quali slave server sono già stati individuati
tale implementazione permette agli slave di essere sempre visibili per poter ricevere nuove simulazioni da eseguire.