
\section{Protocollo di comunicazione}

I tre componenti dell'infrastruttura comunicano tra di loro tramite l'invio di pacchetti sulla rete, utilizzando un protocollo di comunicazione personalizzato. 
I messaggi sono di due possibili tipi: \textbf{comandi} o \textbf{dati}. I comandi sono dei messaggi che danno indicazioni agli altri componenti riguardo i dati che verranno inviati e riguardo alle particolari azioni da eseguire, mentre i dati sono le informazioni che vengono utilizzate per eseguire le azioni richieste dai comandi. In generale entrambi i tipi di messaggi sono composti da degli oggetti Java serializzati ed inviati sulla rete.

\subsection{Comandi scambiati}

\subsubsection{Client}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
       \texttt{INIT}             & Indica l'inizio di una connessione con un master server, è seguito dall'invio del nome della classe \texttt{ModelDefinition} da simulare e dai corrispondenti class bytes \\
       \texttt{DATA}             & Indica l'invio dei dati della simulazione da eseguire, è seguito dall'invio del \texttt{SimulationDataSet} da simulare \\
       \texttt{PING}             & Invia una ping request ad un server \\
       \texttt{CLOSE\_CONNECTION} & Indica la chiusura della connessione con l'host remoto
    \end{tabularx}
\end{table}

\subsubsection{Master}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
        \texttt{INIT} & Indica l'inizio di una connessione con un server slave, è seguito dall'invio del nome della classe \texttt{ModelDefinition} da simulare e dai corrispondenti class bytes \\
        \texttt{PING} & Invia una ping request ad un server \\
        \texttt{TASK} & Indica l'invio di una simulazione ad un server slave, è seguita dall'invio del \texttt{NetworkTask} che verrà eseguito dal server slave \\
        \texttt{RESULTS} & Indica l'invio dei risultati di una simulazione eseguita al client, è seguita dall'invio dell'oggetto \texttt{SamplingFunction} che contiene i risultati di tale simulazione \\
        \texttt{PONG} & Risposta ad una ping request inviata da un altro host \\
        \texttt{INIT\_RESPONSE} & Indica il ricevimento del comando \texttt{INIT} da parte di un client \\
        \texttt{DATA\_RESPONSE} & Indica il ricevimento del comando \texttt{DATA} da parte di un client\\
        \texttt{CLOSE\_CONNECTION} & Indica il ricevimento del comando \texttt{CLOSE\_CONNECTION} da parte di un client e chiude a sua volta la connessione con l'host remoto \\
    \end{tabularx}
\end{table}

\subsubsection{Slave}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
        \texttt{PONG} & Risposta ad una ping request inviata da un altro host \\
        \texttt{INIT\_RESPONSE} & Indica il ricevimento del comando \texttt{INIT} da parte di un server master \\
        \texttt{CLOSE\_CONNECTION} & Indica il ricevimento del comando \texttt{CLOSE\_CONNECTION} da parte di un server master e chiude a sua volta la connessione con l'host remoto \\
    \end{tabularx}
\end{table}

\subsection{Trasporto delle informazioni}
Il trasporto dei messaggi da un nodo all'altro dell'infrastruttura è reso possibile tramite le classi che estendono le interfacce
\texttt{TCPNetworkManager} e \texttt{UDPNetworkManager}, entrambi presenti nel package \texttt{quasylab.sibilla.core.network.communication} e rappresentanti canali di comunicazione basati sui protocolli
del livello di trasporto \textbf{TCP} e \textbf{UDP}.
Gli unici metodi implementati all'interno delle interfacce sono \textbf{factory methods} che restituiscono istanze di classi implementazioni a seconda del valore dei parametri passati come argomento.
Nello specifico, uno dei metodi e richiede come argomento un'istanza di \texttt{NetworkInfo}, contenente
i valori di porta e indirizzo logico del nodo che si vuole contattare assieme al valore di \texttt{NetworkManagerType} specifico del canale di comunicazione che si vuole impiegare, mentre l'altro metodo presente
richiede, rispettivamente in \texttt{TCPNetworkManager} e \texttt{UDPNetworkManager}, un valore di \texttt{TCPNetworkManagerType} assieme ad un'istanza di \texttt{Socket} su cui basare la comunicazione ed un
valore di \texttt{UDPNetworkManagerType} assieme ad un'istanza di \texttt{DatagramSocket}.

\subsubsection{\texttt{TCPNetworkManager} e l'impiego di TLS}
I metodi di interfaccia sono basilari e si limitano all'invio e ricezione di informazioni sotto forma di \texttt{byte[]}, al recupero dell'istanza di \texttt{Socket} su cui è basata la comunicazione tramite \textbf{TCP},
alla chiusura della connessione e all'ottenimento di un'istanza di \texttt{NetworkInfo} contenente porta e indirizzo logico relativi all'altro nodo a cui si è connessi e il valore di \texttt{TCPNetworkManagerType} associato alla particolare implementazione dell'interfaccia.

\texttt{TCPDefaultNetworkManager} e \texttt{TCPSecureNetworkManager} sono le classi presenti nella libreria volte a implementare \texttt{TCPNetworkManager} e rappresentate tramite i valori
\texttt{DEFAULT} e \texttt{SECURE} all'interno della classe enumerazione \texttt{TCPNetworkManagerType}.

Entrambe le classi basano il loro funzionamento su istanze di \texttt{InputStream} e \texttt{OutputStream} ottenute a partire dall'istanza di \texttt{Socket} generata a partire dalla porta e indirizzo logico del nodo dall'altra parte della comunicazione.

La classe \texttt{TCPSecureNetworkManager}, oltre ad offrire lo stesso sistema di comunicazione basato su TCP di \texttt{TCPDefaultNetworkManager}, sfrutta anche il protocollo
\textbf{TLS 1.2} per fornire maggiore sicurezza alla comunicazione di rete. 
TLS 1.2 è la penultima versione del protocollo di sicurezza TLS, successore di \textbf{SSL} e indirizzato a garantire il \textbf{criptaggio} delle informazioni trasmesse,
l'\textbf{autenticazione} dei due nodi tra cui tale comunicazione avviene e l'\textbf{integrità} dei dati trasmessi.
L'avvio di una comunicazione TLS si basa sull'\textbf{handshake} tra i due nodi per poter stabilire la suite di algoritmi da impiegare e permettere ai due nodi di procedere con l'autenticazione.
Nello specifico caso dell'implementazione adottata per lo sviluppo della libreria in esame si è deciso di optare per un'autenticazione a due vie, nella quale ognuno dei due nodi coinvolto nella comunicazione
procede con l'autenticazione dell'altro nodo tramite il suo certificato verificato.

Per poter ricreare totalmente una comunicazione sicura tramite TLS, per ognuno dei tre tipi di nodi alla base dell'architettura sono stati generati un \textbf{keystore} contenente una chiave pubblica ad identificazione del singolo nodo ed un \textbf{truststore} contenente le chiavi pubbliche degli altri nodi coinvolti nelle comunicazioni su rete.
La gestione di tali store di chiavi è delegata alla classe di utilità \texttt{SSLUtils}, con la quale è necessario interagire per poter impiegare \texttt{TCPSecureNetworkManager} nel caso la si scelga come classe per le comunicazioni tra i nodi.
Negli esempi di avvio delle classi della libreria allegati a quest'ultima sono presenti anche i file .jks relativi ai keystore e ai truststore generati durante il lavoro sulla libreria, grazie ai quali è possibile impiegare sin da subito una comunicazione sicura e affidabile tra i vari nodi senza ulteriori operazioni da parte dell'utente.

\subsubsection{\texttt{UDPNetworkManager}}

\subsection{Ulteriori funzionalità}

Per semplificare e migliorare lo scambio di messaggi sono stati implementati dei meccanismi per migliorare ulteriormente lo scambio dei messaggi, tra cui la serializzazione e la compressione.

\subsubsection{Serializzazione}

Per rendere intuitivo l'invio dei messaggi è stato aggiunto un meccanismo di \textbf{serializzazione} per tradurre gli oggetti Java in \texttt{byte[]} che poi verranno inviate in rete tramite i le varie istanze di \texttt{NetworkManager}. In particolare sono stati utilizzati i metodi di \texttt{SerializationUtils}, contenuti all'interno della libreria \textbf{Apache Commons Lang 3}. L'unico requisito necessario affinchè un oggetto Java possa venire serializzato è che quest'ultimo implementi l'interfaccia \texttt{Serializable}.

\subsubsection{Compressione}

Inoltre è stato utilizzato un meccanismo di \textbf{compressione}, contenuto all'interno del pacchetto \texttt{quasylab.sibilla.core.network.compression}. In particolare nella classe \texttt{Compressor} sono presenti due metodi statici, uno per comprimere e l'altro per decomprimere dei dati. Entrambi i metodi prendono in input un \texttt{byte[]} e restituiscono un \texttt{byte[]}, in modo da restituire dei dati pronti per essere inviati in rete per mezzo di un \texttt{NetworkManager}. Al fine di eseguire la \textbf{compressione} dei dati sono stati utilizzate le classi \texttt{GZIPOutputStream} e \texttt{GZIPInputStream}, contenute all'interno del \textbf{package} \texttt{java.io}.

Questo meccanismo è utilizzato nell'invio e nella ricezione degli oggetti \texttt{ComputationResult} scambiati tra server slave e master, che contengono i risultati delle simulazioni eseguite dai server slave. In questo modo otteniamo una \textbf{diminuzione nel tempo di invio} dei risultati delle simulazioni ed una \textbf{diminuzione del traffico} sulla rete, in quanto vengono inviati meno dati in rete.