
\section{Protocollo di comunicazione}

I tre componenti dell'infrastruttura comunicano tra di loro tramite l'invio di pacchetti sulla rete, utilizzando un protocollo di comunicazione personalizzato. 
I messaggi sono di due possibili tipi: \textbf{comandi} o \textbf{dati}. I comandi sono dei messaggi che danno indicazioni agli altri componenti riguardo i dati che verranno inviati e riguardo alle particolari azioni da eseguire, mentre i dati sono le informazioni che vengono utilizzate per eseguire le azioni richieste dai comandi. In generale entrambi i tipi di messaggi sono composti da degli oggetti Java serializzati ed inviati sulla rete.

\subsection{Comandi scambiati}

\subsubsection{Client}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
       \texttt{INIT}             & Indica l'inizio di una connessione con un server Master, è seguito dall'invio del nome della classe \texttt{ModelDefinition} da simulare e dai corrispondenti class bytes \\
       \texttt{DATA}             & Indica l'invio dei dati ad un server Master della simulazione da eseguire, è seguito dall'invio del \texttt{SimulationDataSet} da simulare \\
       \texttt{PING}             & Invia una ping request ad un server \\
       \texttt{CLOSE\_CONNECTION} & Indica la chiusura della connessione con l'host remoto, è seguto dall'invio del nome della classe \texttt{ModelDefinition} usata per le simulazioni che verrà eliminata dai server
    \end{tabularx}
    \captionof{table}{Comandi disponibili per i Client}
\end{table}

\subsubsection{Server Master}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
        \texttt{INIT} & Indica l'inizio di una connessione con un server Slave, è seguito dall'invio del nome della classe \texttt{ModelDefinition} da simulare e dai corrispondenti class bytes \\
        \texttt{PING} & Invia una ping request ad un server \\
        \texttt{TASK} & Indica l'invio di un task di simulazione ad un server Slave, è seguita dall'invio del \texttt{NetworkTask} che verrà eseguito dal server Slave \\
        \texttt{RESULTS} & Indica l'invio dei risultati di una simulazione eseguita al Client, è seguita dall'invio dell'oggetto \texttt{SamplingFunction} che contiene i risultati di tale simulazione \\
        \texttt{PONG} & Risposta ad una ping request inviata da un altro host \\
        \texttt{INIT\_RESPONSE} & Indica il ricevimento del comando \texttt{INIT} da parte di un Client \\
        \texttt{DATA\_RESPONSE} & Indica il ricevimento del comando \texttt{DATA} da parte di un Client\\
        \texttt{CLOSE\_CONNECTION} & Indica il ricevimento del comando \texttt{CLOSE\_CONNECTION} da parte di un Client e chiude a sua volta la connessione con l'host remoto, inoltre è inviato ai server Slave per indicare la chiusura della connessione, in questo caso è seguto dall'invio del nome della classe \texttt{ModelDefinition} usata per le simulazioni che verrà eliminata dai server
    \end{tabularx}
    \captionof{table}{Comandi disponibili per i server Master}
\end{table}

\subsubsection{Server Slave}

\begin{table}[H]
    \begin{tabularx}{\linewidth}{ l X }
        \texttt{PONG} & Risposta ad una ping request inviata da un altro host \\
        \texttt{INIT\_RESPONSE} & Indica il ricevimento del comando \texttt{INIT} da parte di un server Master \\
        \texttt{CLOSE\_CONNECTION} & Indica il ricevimento del comando \texttt{CLOSE\_CONNECTION} da parte di un server Master e chiude a sua volta la connessione con l'host remoto \\
    \end{tabularx}
    \captionof{table}{Comandi disponibili per i server Slave}
\end{table}

\subsection{Trasporto delle informazioni}
Il trasporto dei messaggi da un nodo all'altro dell'infrastruttura è reso possibile tramite le classi che estendono le interfacce
\texttt{TCPNetworkManager} e \texttt{UDPNetworkManager}, entrambi presenti nel package \texttt{quasylab.sibilla.core.network.communication} e rappresentanti canali di comunicazione basati sui protocolli
del livello di trasporto \textbf{TCP} e \textbf{UDP}.
Gli unici metodi implementati all'interno delle interfacce sono \textbf{factory methods} che restituiscono istanze di classi implementazioni a seconda del valore dei parametri passati come argomento.
Nello specifico, uno dei metodi richiede come argomento un'istanza di \texttt{NetworkInfo}, contenente
i valori di porta e indirizzo logico del nodo che si vuole contattare assieme al valore di \texttt{NetworkManagerType} specifico del canale di comunicazione che si vuole impiegare, mentre l'altro metodo presente
richiede, rispettivamente in \texttt{TCPNetworkManager} e \texttt{UDPNetworkManager}, un valore di \texttt{TCPNetworkManagerType} assieme ad un'istanza di \texttt{Socket} su cui basare la comunicazione ed un
valore di \texttt{UDPNetworkManagerType} assieme ad un'istanza di \texttt{DatagramSocket}.

\subsubsection{\texttt{TCPNetworkManager} e l'impiego di TLS}
I metodi di interfaccia sono basilari e si limitano all'invio e ricezione di informazioni sotto forma di \texttt{byte[]}, al recupero dell'istanza di \texttt{Socket} su cui è basata la comunicazione tramite \textbf{TCP},
alla chiusura della connessione e all'ottenimento di un'istanza di \texttt{NetworkInfo} contenente porta e indirizzo logico relativi all'altro nodo a cui si è connessi e il valore di \texttt{TCPNetworkManagerType} associato alla particolare implementazione dell'interfaccia.

\texttt{TCPDefaultNetworkManager} e \texttt{TCPSecureNetworkManager} sono le classi presenti nella libreria volte a implementare \texttt{TCPNetworkManager} e rappresentate tramite i valori
\texttt{DEFAULT} e \texttt{SECURE} all'interno della classe enumerazione \texttt{TCPNetworkManagerType}.

Entrambe le classi basano il loro funzionamento su istanze di \texttt{InputStream} e \texttt{OutputStream} ottenute a partire dall'istanza di \texttt{Socket} generata a partire dalla porta e indirizzo logico del nodo dall'altra parte della comunicazione.

La classe \texttt{TCPSecureNetworkManager}, oltre ad offrire lo stesso sistema di comunicazione basato su TCP di \texttt{TCPDefaultNetworkManager}, sfrutta anche il protocollo
\textbf{TLS 1.2} per fornire maggiore sicurezza alla comunicazione di rete. 
TLS 1.2 è la penultima versione del protocollo di sicurezza TLS, successore di \textbf{SSL} e indirizzato a garantire il \textbf{criptaggio} delle informazioni trasmesse,
l'\textbf{autenticazione} dei due nodi tra cui tale comunicazione avviene e l'\textbf{integrità} dei dati trasmessi.
L'avvio di una comunicazione TLS si basa sull'\textbf{handshake} tra i due nodi per poter stabilire la suite di algoritmi da impiegare e permettere ai due nodi di procedere con l'autenticazione.
Nello specifico caso dell'implementazione adottata per lo sviluppo della libreria in esame si è deciso di optare per un'autenticazione a due vie, nella quale ognuno dei due nodi coinvolto nella comunicazione
procede con l'autenticazione dell'altro nodo tramite il suo certificato verificato.

Per poter ricreare totalmente una comunicazione sicura tramite TLS, per ognuno dei tre tipi di nodi alla base dell'architettura sono stati generati un \textbf{keystore} contenente una chiave pubblica ad identificazione del singolo nodo ed un \textbf{truststore} contenente le chiavi pubbliche degli altri nodi coinvolti nelle comunicazioni su rete.
La gestione di tali store di chiavi è delegata alla classe di utilità \texttt{SSLUtils}, con la quale è necessario interagire per poter impiegare \texttt{TCPSecureNetworkManager} nel caso la si scelga come classe per le comunicazioni tra i nodi.
Negli esempi di avvio delle classi della libreria allegati a quest'ultima sono presenti anche i file .jks relativi ai keystore e ai truststore generati durante il lavoro sulla libreria, grazie ai quali è possibile impiegare sin da subito una comunicazione sicura e affidabile tra i vari nodi senza ulteriori operazioni da parte dell'utente.

Le classi implementazione di \texttt{TCPNetworkManager} vengono impiegate nella libreria per tutte le comunicazioni tra i nodi dell'architettura che non siano relative al discovery di nuovi server Slave.

\subsubsection{\texttt{UDPNetworkManager}}
I metodi di interfaccia si concentrano sull'invio e ricezione di informazioni sotto forma di \texttt{byte[]} e
alla chiusura della connessione. 

L'unica implementazione di tale interfaccia presente nella libreria sviluppata è \texttt{UDPDefaultNetworkManager} e si basa sull'uso di \texttt{DatagramSocket} per poter fornire una comunicazione basilare basata su \textbf{UDP}.
Non sono presenti implementazioni che sfruttino TLS in quanto UDP è, per sua natura, un protocollo non orientato alla connessione e non può pertanto garantire sicurezza e affidabilità delle trasmissioni su rete allo stesso livello di un protocollo orientato alla connessione come TCP.

Le classi implementazione di \texttt{UDPNetworkManager} vengono impiegate nella libreria per lo scambio delle comunicazioni di discovery tra server Master e server Slave.


\subsection{Ulteriori funzionalità}

Per semplificare lo scambio di messaggi sono stati implementati dei meccanismi per migliorare ulteriormente lo scambio dei messaggi, tra cui la serializzazione e la compressione.

\subsubsection{Serializzazione}

Per agevolare l'invio dei comandi e dei dati in rete è stato implementato un meccanismo di \textbf{serializzazione} per tradurre gli oggetti Java in \texttt{byte[]}, poi verranno inviati in rete tramite le istanze di \texttt{TCPNetworkManager} e \texttt{UDPNetworkManager}. 
L'implementazione di tale tipo di serializzazione è stato effettuato tramite la classe \texttt{Serializer}, presente nel package \texttt{quasylab.sibilla.core.network.serialization}, basandosi sulla classe \texttt{org.apache.commons.lang3.SerializationUtils}.
L'unico requisito necessario affinchè un oggetto Java possa venire serializzato è che quest'ultimo implementi l'interfaccia \texttt{Serializable}.

\subsubsection{Compressione}

Inoltre è stato introdotto un meccanismo di \textbf{compressione}, contenuto all'interno del pacchetto \texttt{quasylab.sibilla.core.network.compression}. In particolare nella classe \texttt{Compressor} sono presenti due metodi statici, uno per comprimere e l'altro per decomprimere dei dati. Entrambi i metodi prendono in input un \texttt{byte[]} e restituiscono un \texttt{byte[]}, in modo da restituire dei dati pronti per essere inviati in rete per mezzo di istanze di \texttt{TCPNetworkManager} o di \texttt{UDPNetworkManager}. Al fine di eseguire la \textbf{compressione} dei dati sono state utilizzate le classi \texttt{GZIPOutputStream} e \texttt{GZIPInputStream}, contenute all'interno del package \texttt{java.util.zip}.

Questo meccanismo è utilizzato nell'invio e nella ricezione degli oggetti \texttt{ComputationResult} scambiati tra server Slave e Master, che contengono i risultati delle simulazioni eseguite dai server Slave. In questo modo otteniamo una \textbf{diminuzione nel tempo di invio} dei risultati delle simulazioni ed una \textbf{diminuzione del traffico} sulla rete, in quanto vengono inviati meno dati in rete.